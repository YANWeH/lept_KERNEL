# part1：PCBootstrap

## `PC's layout`

![](images\lab1_part1_PC's layout.jpg)

第一代PC处理器是16位字长的Intel 8088处理器，这类处理器只能访问1MB的地址空间，即0x00000000~0x000FFFFF。但是这1MB也不是用户都能利用到的，只有低640KB(0x00000000~0x000A0000)的地址空间是用户程序可以使用的。如图所示。

而剩下的384KB的高地址空间则被保留用作其他的目的，比如(0x000A0000~0x000C0000)被用作屏幕显示内容缓冲区，其他的则被非易失性存储器(ROM)所使用，里面会存放一些固件，其中最重要的一部分就是BIOS，占据了0x000F0000~0x00100000的地址空间。BIOS负责进行一些基本的系统初始化任务，比如开启显卡，检测该系统的内存大小等等工作。在初始化完成后，BIOS就会从某个合适的地方加载操作系统。



## exercise2：

实模式下，指令中出现的地址都是采用	**(段基址：段内偏移)**

```shell
The target architecture is assumed to be i8086
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b
```

在执行gdb时，会出现以上的指令

由于8088CPU中寄存器都是16位，而CPU地址总线是20位的，我们怎么通过16位的寄存器去拼接20位的地址呢？

　　所以我们需要采用下面的方法：**把段寄存器中的值左移4位，形成20位段基址，然后和16位段内偏移相加，就得到了真实地址。**比如上面的指令中段寄存器的内容为`0xf000`，所以真实地址为 

```
0xf000<<4+0xe05b = 0xfe05b
```

使用si命令查看启动时的汇编代码：

`汇编命令	src	dst`

```shell
[f000:fff0]    0xffff0:	ljmp   $0xf000,$0xe05b	//跳转
0x0000fff0 in ?? ()
+ symbol-file obj/kern/kernel
(gdb) si
[f000:e05b]    0xfe05b:	cmpl   $0x0,%cs:0x6ac8	//比较寄存器$0x0与寄存器%cs:0x6ac8的值
0x0000e05b in ?? ()
(gdb) 
[f000:e062]    0xfe062:	jne    0xfd2e1	//jump if not equal--从上面的比较结果来跳转
0x0000e062 in ?? ()
(gdb) 
[f000:e066]    0xfe066:	xor    %dx,%dx	//xor（异或），异或本身，置零
0x0000e066 in ?? ()
(gdb) 
[f000:e068]    0xfe068:	mov    %dx,%ss	//将%dx移入%ss
0x0000e068 in ?? ()
(gdb) 
[f000:e06a]    0xfe06a:	mov    $0x7000,%esp
0x0000e06a in ?? ()
(gdb) 
[f000:e070]    0xfe070:	mov    $0xf34c2,%edx
0x0000e070 in ?? ()
(gdb) 
[f000:e076]    0xfe076:	jmp    0xfd15c	//无条件跳转
0x0000e076 in ?? ()
(gdb) 
[f000:d15c]    0xfd15c:	mov    %eax,%ecx
0x0000d15c in ?? ()
(gdb) 
[f000:d15f]    0xfd15f:	cli    //clear interupt 关闭中断指令
0x0000d15f in ?? ()
(gdb) 
[f000:d160]    0xfd160:	cld	//clear direction 设置方向标识位，置零则代表内存地址的变化方向从低地址值变为高地址
0x0000d160 in ?? ()
[f000:d161]    0xfd161:	mov    $0x8f,%eax
0x0000d161 in ?? ()
(gdb) 
[f000:d167]    0xfd167:	out    %al,$0x70	//将%al读入$0x70
0x0000d167 in ?? ()
(gdb) 
[f000:d169]    0xfd169:	in     $0x71,%al	//将$0x71写入%al
0x0000d169 in ?? ()
[f000:d16b]    0xfd16b:	in     $0x92,%al
0x0000d16b in ?? ()
(gdb) 
[f000:d16d]    0xfd16d:	or     $0x2,%al		//或
0x0000d16d in ?? ()
(gdb) 
[f000:d16f]    0xfd16f:	out    %al,$0x92
0x0000d16f in ?? ()
[f000:d171]    0xfd171:	lidtw  %cs:0x6ab8	//加载中断向量表寄存器IDTR
0x0000d171 in ?? ()
[f000:d177]    0xfd177:	lgdtw  %cs:0x6a74	//把从0xf6a74为起始地址处的6个字节的值加载到全局描述符表格寄存器中GDTR中
0x0000d177 in ?? ()
[f000:d17d]    0xfd17d:	mov    %cr0,%eax	//计算机中包含CR0~CR3四个控制寄存器，用来控制和确定处理器的操作模式
0x0000d17d in ?? ()
(gdb) 
[f000:d180]    0xfd180:	or     $0x1,%eax
0x0000d180 in ?? ()
(gdb) 
[f000:d184]    0xfd184:	mov    %eax,%cr0	//CR0寄存器的0bit是PE位，启动保护位，当该位被置1，代表开启了保护模式
0x0000d184 in ?? ()
(gdb)
```

操作CMOS存储器中的内容需要两个端口，一个是0x70另一个就是0x71。

每一种中断都有自己对应的中断处理程序，那么这个中断的处理程序的首地址就叫做这个中断的中断向量。

**PC启动后的运行顺序为 BIOS --> boot loader --> 操作系统内核**



# part2：The Boot loader

`boot loader`主要做两件事：

1. 创建两个全局描述符表项（代码段和数据段），然后进入保护模式
2. 从磁盘加载kernel到内存

`boot loader`:引导加载程序（boot loader） 会引导操作系统。当机器引导它的操作系统时，BIOS 会读取引导介质上最前面的 512 字节（即人们所知的 主引导记录（master boot record，MBR））。在单一的 MBR 中只能存储一个操作系统的引导记录，所以当需要多个操作系统时就会出现问题。所以需要更灵活的引导加载程序。



**elf文件**：elf是一种文件格式，主要被用来把程序存放到磁盘上。是在程序被编译和链接后被创建出来的。一个elf文件包括多个段。对于一个可执行程序，通常包含存放代码的文本段(text section)，存放全局变量的data段，存放字符串常量的rodata段。elf文件的头部就是用来描述这个elf文件如何在存储器中存储。

需要注意的是，你的文件是可链接文件还是可执行文件，会有不同的elf头部格式

在采用段式内存管理的架构中(比如intel的80x86系统)，bss段(ted by Symbol segment)通常是指用来存放程序中未初始化的全局变量的一块内存区域，一般在初始化时 bss 段 Block Star部分将会清零。bss段属于静态内存分配，即程序一开始就将其清零了。在C语言之类的程序编译完成之后，已初始化的全局变量保存在 .data 段中，未初始化的全局变量保存在 .bss 段中 。

段			 	介绍
`.text`		 已编译代码所在的位置
`.data`		全局表、变量等所在的位置
`.bss`		  不要在你的文件中寻找.bss的相关存储信息，因为那是不存在的。为什么不存在呢？因为那是你代码中				 未初始化数组和变量所在的地方，加载器 "知道"它们应该被赋值为零......但是在你的磁盘上存储这些未				 初始化的零是没有任何意义的( 浪费空间 )，不是吗？

## 实模式与保护模式：

**实模式**是早期CPU运行的工作模式，而**保护模式**则是现代CPU运行的模式

**实模式**出现于早期8088CPU时期。当时由于CPU的性能有限，一共只有20位地址线（所以地址空间只有1MB），以及8个16位的通用寄存器，以及4个16位的段寄存器。所以为了能够通过这些16位的寄存器去构成20位的主存地址，必须采取一种特殊的方式。当某个指令想要访问某个内存地址时，它通常需要用下面的这种格式来表示：

　　**`(段基址：段偏移量)`**

其中第一个字段是段基址，它的值是由段寄存器提供的。段寄存器有4种，%cs，%ds，%ss，%es。具体这个指令采用哪个段寄存器是由这个指令的类型来决定的。比如要取指令就是采用%cs寄存器，要读取或写入数据就是%ds寄存器，如果要对堆栈操作就是%ss寄存器。总之，不管什么指令，都会有一个段寄存器提供一个16位的段基址。

第二字段是段内偏移量，代表你要访问的这个内存地址距离这个段基址的偏移。它的值就是由通用寄存器来提供的，所以也是16位。那么问题来了，两个16位的值如何组合成一个20位的地址呢？这里采用的方式是把段寄存器所提供的段基址先向左移4位。这样就变成了一个20位的值，然后再与段偏移量相加。所以算法如下：

　　**`物理地址 = 段基址<<4 + 段内偏移`**

所以假设 %cs中的值是0xff00，%ax = 0x0110。则(%cs:%ax)这个地址对应的真实物理地址是 0xff00<<4 + 0x0110 = 0xff110。

上面就是实模式访问内存地址的原理。

发现 实模式中每次都是直接操作物理地址，如果操作失误、不当 可能会造成系统崩塌 等极为严重的事件。

并且随着CPU的发展，CPU的地址线的个数也从原来的20根变为现在的32根，所以可以访问的内存空间也从1MB变为现在4GB，寄存器的位数也变为32位。所以实模式下的内存地址计算方式就已经不再适合了。所以就引入了现在的保护模式，实现更大空间的，更灵活的内存访问。



在计算机中存在两个表，GDT，LDT。它们两个其实是同类型的表，前者叫做全局段描述符表，后者叫做本地段描述符表。他们都是用来存放关于某个运行在内存中的程序的分段信息的。比如某个程序的代码段是从哪里开始，有多大；数据段又是从哪里开始，有多大。GDT表是全局可见的，也就是说每一个运行在内存中的程序都能看到这个表。所以操作系统内核程序的段信息就存在这里面。还有一个LDT表，这个表是每一个在内存中的程序都包含的，里面指明了每一个程序的段信息。

![](images\lab1_part2_GDT&LDT.jpg)

我们从图中可以看到，无论是GDT，还是LDT。每一个表项都包括三个字段：

　　Base : 32位，代表这个程序的这个段的基地址。

　　Limit : 20位，代表这个程序的这个段的大小。

　　Flags ：12位，代表这个程序的这个段的访问权限。

保护模式并不像实模式那样，segment : offset，直接将 segment 作为基地址，与offset偏移量直接相加。 而是，把segment的值作为一个selector(选择器)，代表这个段的段表项在GDT/LDT表的索引。

系统会给程序自动分配程序段,代码段等,这些段以及偏移组成了逻辑地址,而逻辑地址通过GDTR/LDTR , 首先根据Flags字段判断能否访问此段内容（这样子是为了对进程间的地址进行保护），如果能访问，则把Base字段(段基址)的内容取出 直接与offset相加得到 线性(虚拟)地址。

### 为什么要开启A20地址线呢？

- **在 A20 Gate 被禁止时，**表现依然会与`8086/8088`一样，依然拥有`地址环绕`，也就是，只有A0 - A19 能运作。默认是被禁止，因为BIOS是最先执行的程序。即实模式
- **在 A20 Gate 被开启时，**就可以访问1MB以上的内存空间。即保护模式

CR0

是系统内的控制寄存器之一。控制寄存器是一些特殊的寄存器，它们可以控制CPU的一些重要特性。

0位(CR0)是保护允许位PE(Protedted Enable)，用于启动保护模式。

如果PE=1，则启动保护模式。

如果PE=0，则禁用保护模式（只能以实模式运行，拥有地址环绕）。



## exercise3：

1. 在什么时候处理器开始运行于32bit模式？到底是什么把CPU从16位切换为32位工作模式？

答：在boot.S文件中，计算机首先工作于实模式，此时是16bit工作模式。当运行完 " ljmp $PROT_MODE_CSEG, $protcseg " 语句后，正式进入32位工作模式。根本原因是此时CPU工作在保护模式下。

 

2. boot loader中执行的最后一条语句是什么？内核被加载到内存后执行的第一条语句又是什么？

答：boot loader执行的最后一条语句是bootmain子程序中的最后一条语句 " ((void (*)(void)) (ELFHDR->e_entry))(); "，即跳转到操作系统内核程序的起始指令处。

　　   这个第一条指令位于/kern/entry.S文件中，第一句 movw $0x1234, 0x472

　　

3. 内核的第一条指令在哪里？

答：上一个问题中已经回答过这个问题，第一条指令位于/kern/entry.S文件中。

 

4. boot loader是如何知道它要读取多少个扇区才能把整个内核都送入内存的呢？在哪里找到这些信息？

答：首先关于操作系统一共有多少个段，每个段又有多少个扇区的信息位于操作系统文件中的Program Header Table中。这个表中的每个表项分别对应操作系统的一个段。并且每个表项的内容包括这个段的大小，段起始地址偏移等等信息。所以如果我们能够找到这个表，那么就能够通过表项所提供的信息来确定内核占用多少个扇区。

　　　那么关于这个表存放在哪里的信息，则是存放在操作系统内核映像文件的ELF头部信息中。



## exercise4：



## exercise5:

内核的`加载地址`和`链接地址`。和boot loader不同，内核的这两个地址是不同的。内核告诉boot loader把它加载到低地址处（加载地址——实际地址），但是它希望运行在高地址处（链接地址——期望地址）。

1. VMA（Virtual Memory Address）：虚拟内存地址，代码要运行的时候，此时对应的地址，就是VMA。
2. LMA（Load Memory Address）：内存装载地址，代码被装载到内存的某个地方，那个地方的地址，就是LMA。



## exercise6:

我们将尝试使用GDB的x命令（查看内存命令）。 x/Nx ADDR。这个指令将打印出从ADDR地址开始之后的N个字的内容。重启一下Qemu。在Bios进入boot loader之前，内存地址0x00100000处8个字的内容，然后进入boot loader运行到内核开始处停止，再看下这个地址处的值。为什么二者不同？第二次这个内存处所存放的值的含义是什么？

因为bootmain函数在最后会把内核的各个程序段送入到内存地址0x00100000处，所以这里现在存放的就是内核的某一个段的内容，由于程序入口地址是0x0010000C，正好位于这个段中，所以可以推测，这里面存放的应该是指令段，即.text段的内容。



# part3：the kernel

part3主要介绍进入内核后的一些操作：

1. 首先会开启分页模式。
2. 格式化输出字符串的原理。本质还是往物理内存0xB8000起始的显存写数据。
3. 函数调用过程

## exercise7:

使用虚拟内存解决位置依赖问题



## exercise8:

register修饰符暗示编译程序相应的变量将被频繁地使用，如果可能的话，应将其保存在CPU的寄存器中，以加快其存储速度。

![](images\lab1_part3_输出函数调用关系.jpg)

 **1. 解释一下printf.c和console.c两个之间的关系。console.c输出了哪些子函数？这些子函数是怎么被printf.c所利用的？**

　 答：在console.c中除了被static修饰符修饰的函数之外，都可以被外部所使用，其中被printf所使用的函数就是cputchar子函数。

2.解释console.c中的代码？

```c
if (crt_pos >= CRT_SIZE) {
	int i;
	memmove(crt_buf, crt_buf + CRT_COLS, (CRT_SIZE - CRT_COLS) * sizeof(uint16_t));
	for (i = CRT_SIZE - CRT_COLS; i < CRT_SIZE; i++)
		crt_buf[i] = 0x0700 | ' ';
		crt_pos -= CRT_COLS;
      }
```

控制台显式内容大小为`crt_rows*crt_cols`即25*80；当用完后，只能将行整体上移，即memmove（），再将最后一行初始为空



## exercise9：

**X86堆栈指针寄存器（%esp）**指向的是整个堆栈中正在被使用的部分的最低地址。在这个地址之下的更低的地址空间都是还没有被利用的堆栈空间。当计算机要完成把一个值压入堆栈的动作时，通常它需要先把堆栈指针寄存器中的值减1（有时候是减4，由机器字长决定），然后把需要压入的值存放到当前堆栈指针寄存器所指向的新的内存单元。而从堆栈中弹出一个值的操作，则需要计算机首先从堆栈寄存器所指向的内存单元读取一个数据，然后把堆栈寄存器的值加1（有时候是加4）。在32bit模式下，每一次对堆栈的操作都是以32bit为单位的，所以%esp中的值永远都是可以被4整除的。

　　**而ebp寄存器**则是记录每一个程序的栈帧的相关信息的一个非常重要的寄存器。每一个程序在运行时都会分配给它一个栈帧，用于实现存放一些临时变量，传递参数给它调用的子函数等等功能。当现在进入某个子程序时，最先要运行的代码就是先把之前调用这个子程序的程序的ebp寄存器的值压入堆栈中保存起来，然后把ebp寄存器的值更新为当前esp寄存器的值。此时就相当于为这个子程序定义了它的ebp寄存器的值，也就是它栈帧的一个边界。只要所有的程序都遵循这样的编程规则，那么当我们运行到程序的任意一点时。我们可以通过在堆栈中保存的一系列ebp寄存器的值来回溯，弄清楚是怎样的一个函数调用序列使我们的程序运行到当前的这个点。

1.**内核是如何给它的堆栈保留一块内存空间的？**

　  其实就是通过刚刚分析的，在entry.S中的数据段里面声明一块大小为32Kb的空间作为堆栈使用。从而为内核保留了一块空间。



## exercise10:



## exercise11：

实现backtrace子程序：这个子程序的功能就是要显示当前正在执行的程序的栈帧信息。包括当前的ebp寄存器的值，这个寄存器的值代表该子程序的栈帧的最高地址。eip则指的是这个子程序执行完成之后要返回调用它的子程序时，下一个要执行的指令地址。后面的值就是这个子程序接受的来自调用它的子程序传递给它的输入参数。

![](images\lab1_part3_ebp&esp.jpg)

![](images\lab1_part3_函数调用ebp关系.jpg)

stab表是什么？

GCC把C语言源文件( ‘.c’ )编译成汇编语言文件( ‘.s’ ), 汇编器把汇编语言文件翻译成目标文件( ‘.o’ )。在目标文件中, 调试信息用 ‘.stab’ 打头的一类汇编指导命令表示, 这种调试信息格式叫’Stab’, 即符号表(Symbol table)。这些调试信息包括行号、变量的类型和作用域、函数名字、函数参数和函数的作用域等源文件的特性。

